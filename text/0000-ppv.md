- Feature Name: `minimal_portable_packed_vector_types`
- Start Date: (fill me in with today's date, YYYY-MM-DD)
- RFC PR: (leave this empty)
- Rust Issue: (leave this empty)

# Summary
[summary]: #summary

This RFC adds:

* portable vector types up to 256-bit
* the minimal API of these types

This is Chapter I of the portable packed SIMD vector types quest-line:

* I [RFCXYZW](): vector types (up to 256-bit) and minimal API.
* _: casts (From/Into) and conversions (FromBits/IntoBits)
* _: aligned/unaligned load/stores
* _: Debug
* _: Default
* _: arithmetic operations
* _: bitwise operations
* _: shuffles
* _: gather/scatter
* _: arithmetic reductions
* _: bitwise reductions
* _: min/max reductions
* _: boolean vectors
* _: boolean reductions
* _: comparisons
* _: PartialEq, PartialOrd, Eq, Ord
* _: Hash
* _: formatting (LowerHex)
* _: 512-bit vector types and masks
* _: half-float (f16) vectors

# Motivation
[motivation]: #motivation

The `std::arch` module exposes architecture-specific SIMD types like `_m128` - a
128-bit wide SIMD type. How these bits are interpreted depends on the intrinsics
being used. For example, let's sum 8 `f32`s values using the SSE4.1 facilities
in the `std::arch` module. This is one way to do it
([playground](https://play.rust-lang.org/?gist=165e2886b4883ec98d4e8bb4d6a32e22&version=nightly)):

```rust
unsafe fn add_reduce(a: __m128, b: __m128) -> f32 {
    let c = _mm_hadd_ps(a, b);
    let c = _mm_hadd_ps(c, _mm_setzero_ps());
    let c = _mm_hadd_ps(c, _mm_setzero_ps());
    std::mem::transmute(_mm_extract_ps(c, 0))
}

fn main() {
    unsafe {
        let a = _mm_set_ps(1., 2., 3., 4.);
        let b = _mm_set_ps(5., 6., 7., 8.);
        let r = add_reduce(a, b);
        assert_eq!(r, 36.);
    }
}
```

Notice that:

* one has to put some effort to extrapolate with the signature what `add_reduce`
  actually does: "ok, add_reduce, takes 128-bit vectors, returns a `f32`, ah!
  Those 128-bit vectors should probably contain 4 packed f32s!"
  
* it requires a lot of unsafe code: the intrinsics are unsafe, the intrinsic API
  relies on the user performing transmutes

* it requires a lot of architecture specific knowledge: how the intrinsics are
  called, how they are used together
  
* this solution only works on `x86` or `x86_64` with SSE3 enabled.

With portable packed vector types we can do much better
([playground](https://play.rust-lang.org/?gist=7fb4e3b6c711b5feb35533b50315a5fb&version=nightly)):

```rust
fn main() {
    let a = f32x4::new(1., 2., 3., 4.);
    let b = f32x4::new(5., 6., 7., 8.);
    let r = (a + b).sum();
    assert_eq!(r, 36.);
}
```

in both cases, the same code is generated:

```asm
  haddps xmm0, xmm1
  xorps xmm1, xmm1
  haddps xmm0, xmm1
  haddps xmm0, xmm1
```

# Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

This RFC introduces portable packed SIMD vector types and their minimal API. Here:

* portable: is the opposite of architecture-specific. These types work both
  correctly and efficiently on all architectures. They are a zero-overhead
  abstraction, that is, for the operations that these types support, one cannot
  write better code by hand (otherwise it is an implementation bug).
  
* packed: is the opposite of "scalable" or "Cray vectors". That is, these
  vector's have a compile-time fixed length. They can be stored inside structs,
  on the stack, on the heap, passed via ABIs.
  
# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation
  
## Vector types

The vector types are named according to the following scheme:

> {element_type}{element_width}x{number_of_lanes}

where the following element types are introduced by this RFC:

* `i`: signed integer
* `u`: unsigned integer
* `f`: float

So that `u16x8` reads "a SIMD vector of eight packed 16-bit wide unsigned
integers". The width of a vector can be computed by multiplying the
`{element_width}` times the `{number_of_lanes}`. For `u16x8`, 16 x 8 = 128, so
this vector type is 128 bits wide.

> Note: this nomenclature follows closely the nomenclature used by ARM in their
> vector types: <type><size>x<number of lanes>_t

This RFC proposes adding all vector types with sizes in range [16, 256] bit to
the `std::simd` module, that is:

* 16-bit wide vectors:
  * `i8x2`
  * `u8x2`
* 32-bit wide vectors:
  * `i8x4`
  * `u8x4`
  * `i16x2`
  * `u16x2`
* 64-bit wide vectors:
  * `i8x8`
  * `u8x8`
  * `i16x4`
  * `u16x4`
  * `i32x2`
  * `u32x2`
  * `f32x2`
* 128-bit wide vectors:
  * `i8x16`
  * `u8x16`
  * `i16x8`
  * `u16x8`
  * `i32x4`
  * `u32x4`
  * `f32x4`
  * `i64x2`
  * `u64x2`
  * `f64x2`

Note that half-float (`f16`) vectors are not part of this RFC but will need to
be covered by future RFCs extending this one.

## Minimal portable packed SIMD vector types API

This RFC proposes a minimal API that is the fundation for other APIs that will
be proposed later.

### Traits

All portable vector types implement the following traits: `Copy`, `Clone`.

### Inherent Methods

All portable vector types implement the following methods:

> Note: except for boolean-vector types which are not proposed here. These will
> have their own minimal API proposed in a future RFC.

```rust
impl {element_type}{element_width}x{number_of_lanes} {

/// Creates a new instance of the vector from `number_of_lanes` 
/// values.
pub const fn new(args...) -> Self;

/// Returns the number of vector lanes.
pub const fn lanes() -> usize;

/// Constructs a new instance with each element initialized to
/// `value`.
pub const fn splat(value: element_type) -> Self;

/// Extracts the value at `index`.
///
/// # Panics
///
/// If `index >= Self::lanes()`.
pub fn extract(self, index: usize) -> element_type;

/// Extracts the value at `index`.
///
/// If `index >= Self::lanes()` the behavior is undefined.
pub unsafe fn extract_unchecked(self, index: usize) -> element_type;

/// Returns a new vector where the value at `index` is replaced by `new_value`.
///
/// # Panics
///
/// If `index >= Self::lanes()`.
#[must_use = implementation-defined]
pub fn replace(self, index: usize, new_value: $elem_ty) -> Self;

/// Returns a new vector where the value at `index` is replaced by `new_value`.
///
/// # Panics
///
/// If `index >= Self::lanes()`.
#[must_use = implementation-defined]
pub unsafe fn replace_unchecked(self, index: usize, 
                                new_value: element_type) -> Self;

}
```

# TODO: ABI 

TODO: @acrichto: IIRC currently the Rust ABI for SIMD types always passes
vector types by pointers. This avoids the issues mentioned in:
https://github.com/rust-lang/rust/issues/44367

How exactly this work is pretty important and should be explained here. 

Then we have the issue that SIMD types in `extern` functions might not be sound.
IIRC this is currently disallowed. Is there an issue for this? 

# Drawbacks
[drawbacks]: #drawbacks

The main drawback is that in a future where Rust has multiple backends,
providing this types will take some work. Most backeds support vector types in
one form or another, and if the backend supports the architecture-specific
vector types exposed by `std::arch` chances are that very little work will
actually be required to support this.

# Rationale and alternatives
[alternatives]: #alternatives

TODO: @acrichto: passing vector types on the stack vs on function arguments.

What where the alternatives here? We discussed simd ABIs as a feature, shims,
... and many other things, and they all caused problems with trait methods,
function pointers, etc.

# Prior art
[prior-art]: #prior-art

All of this is implemented in `stdsimd` and can be used on nightly today via the
`std::simd` module. The `stdsimd` crate is an effort started by @burntsushi to
put the `rust-lang-nursery/simd` crate into a state suitable for stabilization.
The `rust-lang-nursery/simd` crate was mainly developed by @huonw and IIRC it is
heavily-inspired by Dart's SIMD which is from where the `f32x4` naming scheme
comes from.

# Unresolved questions
[unresolved]: #unresolved-questions

TBD.
